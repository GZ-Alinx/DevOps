
名词解释。


1、单内核：
单内核就是把它从整体上作为一个单独的大过程来实现，并同时运行在一个单独的地址空间。即所有内核服务都在一个大的内核空间中运行，内核可以直接调用函数。Linux是一个单内核，它运行在单独的内核地址空间。单内核模式具有简单和高性能的特点。

2、进程、线程、内核线程：
进程：一个进程就是处于执行期的程序以及它所包含的资源的总称。这些资源包括：打开的文件、挂起的信号、内核内部数据、处理器状态、地址空间及一个或多个执行线程等。
线程：线程是在进程中活动的对象，它为共享一个地址空间的程序提供多个执行线索，它可以共享打开的文件和其他资源。内核调度的对象是线程而不是进程，每个线程拥有一个独立的程序计数器、进程栈和一组进程寄存器。在Linux中每个线程和进程一样有唯一（唯一隶属自己）的task_struck，在内核看来与一般进程没有什么区别，当进程间选择性的共享地址空间时它可视为线程。
内核线程：独立运行在内核空间的标准进程，可以被调度，也可以被抢占，但是没有独立的地址空间，只在内核空间运行，负责完成内核在后台执行操作的任务，只能由其他内核线程创建。

3、进程上下文：
我们把系统提供给进程的处于动态变化的运行环境总和称为进程上下文，这些资源包括CPU的所有寄存器中的值、进程的状态以及堆栈中的内容，当前进程上下文均保存在进程的任务数结构中。一般程序在用户空间运行，它执行了系统调用或者触发了某个异常，它就陷入了内核空间，此时我们称“内核代表进程执行”并处于进程上下文。

4、写时拷贝：
写时拷贝是指在需要写入的时候才进行资源复制，是一种可以推迟甚至免除拷贝数据的技术。Linux的fork()使用写时拷贝数据实现，创建子进程时不需要立即给子进程拷贝数据，而是让父子进程以只读的方式共享没有修改的数据和空间，而当父子进程之一修改数据时则进行拷贝。

5、内核抢占/抢占：
内核抢占是指，当进程位于内核空间，若有一个更高优先级的任务出现时，可以将当前任务挂起，切换去执行优先级更高的进程，而这个强制挂起的动作叫抢占。可抢占的前提需要确保重新调度是安全的，即当前的任务没有持有锁，在这种情况下内核可以在任何时间抢占正在执行的任务。2.6版本后的Linux内核是可抢占式内核，具有上述允许内核优先执行高优先级任务的能力。

6、进程时间片：
进程时间片是指，进程在被抢占前所能持续运行的CPU时间，它是一个有系统调度策略设定的数值。Linux采用了预加载调度策略，每个进程只运行很短的时间：200毫秒；同时Linux调度程序还能根据进程的优先级动态调整分配给它的时间片，来保证高优先级的进程执行的高频率和长时间。

7、上下文切换：
从一个可执行的进程切换到另一个可执行的进程。由context_switch()函数负责完成，它完成了两项基本工作：1）把虚拟内存从上一个进程映射切换到新进程中；2）从上一个进程的处理器状态切换到新进程的处理器状态中，包括保存、恢复、栈信息和寄存器信息。

8、系统调用（※）：
    所有的操作系统在其内核里都有一些内建的接口函数，这些函数可以用来完成一些系统级别的功能。Linux系统使用的这样的函数叫做“系统调用”，英文是systemcall。这些函数代表了从用户空间到内核空间的一种转换，应用程序通过这些接口函数访问硬件设备和其他的操作系统资源。Linux中，系统调用时用户空间访问内核的唯一手段，除异常和陷入之外，它们是内核唯一的合法入口。

9、中断上下文：
当执行一个中断处理程序时或下半部时，内核处于中断上下文。硬件通过触发信号，导致内核调用中断处理程序，进入内核空间。这个过程中，硬件的一些变量和参数也要传递传递给内核，内核根据这些参数进行中断处理。所谓“中断上下文”，其实也可以看作就是硬件传递过来的这些参数和内核需要保存的一些其他环境。

10、中断机制：
当硬件处理I/O等操作时，内核在此期间处理其他事物而不等待硬件完成，当硬件直至完成了请求的操作后，再通知内核回过头来处理，这就是中断机制。

11、触发软中断：
一个注册的软中断必须在被标记后才会执行，这被称作触发软中断（raisingthe softirq）。

12、临界区：（critical  region）
访问和操作共享数据的代码段，整个临界区是一个不可分割的指令。

13、同步：
避免并发和防止竞争条件被称为同步（sysnchronization）。

14、死锁：
有一个或多个执行线程和一个或多个资源，每个线程都在等待其中的一个资源，但所有的资源都已经被占用了，所有线程都在相互等待，但它们永远不放弃已经占有的资源，于是任何线程都无法继续，这便发生了死锁。

15、竞争条件（race conditon）：
多个线程或者进程在读写一个共享数据时依赖于它们执行的相对时间，这种情形叫竞争。这样的多个线程或者进程可能处于同一个临界区之中，竞争条件就发生在这多个进程或者线程在读写数据时，其最终的结果依赖于多个进程的指令执行顺序。

16、争用（lock contention）（8.4）：
确切应该是锁的争用，是指当锁正在被占用时，有其他线程试图获得该锁。

17、自旋锁（9）：
Linux内核最常见的锁。一个执行线程要想访问被自旋锁保护的共享资源，必须先得到锁，而自旋锁最多只能被一个可执行的线程持有。锁持有者在访问完共享资源后必须释放锁。而如果一个执行线程在获取自旋锁时，没有任何执行线程保持锁，则立即得到锁；若获取自旋锁时已经被持有，那么该线程就会一直进行“忙循环”——“旋转”——“等待锁重新可用”的自旋锁，直到所要自旋锁的保持者释放锁，请求锁的执行线程便能立即得到它。

18、屏障：
所有可能重新排序和写的处理器提供了机器指令来确保顺序要求，同样也可以指编译器不要给定点周围的指令序列进行重新排序，这些确保顺序的指令叫屏障。

19、文件系统（p167）：
文件系统是特殊的数据分层存储结构，它包括文件、目录和相关的控制信息，它负责管理和存储文件信息。文件系统的通用操作包含创建、删除和安装等等。
虚拟文件系统（VFS）：作为内核子系统，为用户空间程序提供了文件系统相关的接口。系统中的所有文件系统不但依赖VFS共存，而且也依靠VFS系统协同工作。

21、软实时：
    内核调度进程，尽力使进程在它的限定时间到来前运行，但内核不保证总能满足这些进程的需求。

22、延迟写：
当进程往磁盘上写数据时，先往高速缓存中写，以便随后又读它时，能从高速缓存中读取，而不必启动磁盘读取。Linux采取了“延迟写”策略，即：如果缓冲区还没有写满，则不急于把缓冲区的内容写到磁盘上，而是在缓冲管理数据结构中对该缓冲区设置延迟写标志，当高速缓存中的数据延迟到必须往磁盘上写的时候才进行写盘操作。

23、内核模块：
模块就是一个已编译但未连接的可执行文件。Linux是一个一体化内核，内核中各部件联系紧密，运行效率高；但是当因某种原因需要增加、扩充时，用户必须对内核全部编译一次，为弥补这个缺点，Linux建立了模块机制。
从内核角度看，模块是运行时可连接、可删除的，包含了至少两个函数的代码段。这个代码段一旦被连接到内核，它就是内核的一部分，所以称为内核模块。
从用户角度看，模块是内核的一个外挂的配件，需要时可将其挂接到内核，不需要时即可将其删除，它为用户提供了扩充内核功能的？？。

24、索引节点：
一个索引节点代表文件系统中（虽然索引节点仅当文件被访问时，才？创建）的一个文件，它也可以是设备或者管道这样的特殊文件。



二、问答题：
1、简述linux内核特点（1.3）。
答：Linux是单内核，但汲取了微内核的精华，其特点如下：
1）支持动态加载内核模块，可动态的卸除和加载部分内核代码；
2）支持对称多处理机制（SMP）；
3）内核可抢占，允许内核执行高优先级的任务；
4）独特的线程实现，内核不区分线程和其他一般进程，一样都是task；
5）设备管理中提供具有设备类的面向对象的设备模型、热插拔事件、以及用户空间的设备文件系统；
6）抛弃了Unix中拙劣的stream特性，忽略了一些实际上已经不会使用的过时标准；
7）自由，公开开发模型自由务实发展。
2、简述linux内核开发的差异（所注意的事项）（2.4）。
答：1）不能访问C库，对内核而言C库太大了，但大部分常用C库函数在内核中都有实现；
2）必须使用GNU C；
3）缺乏内存保护机制，内核中的内存都不分页；
4）浮点数很难使用，复杂繁琐，原则是不要在内核中使用浮点数；
5）只有容积很小且定长的堆栈；
6）内核支持异步中断、抢占和SMP，所以容易出现竞争条件，要求时刻注意同步和并发，设置同步机制保证不出现竞争条件，通过自旋锁和信号量解决竞争条件；
7）要注重可移植性。
3、进程创建的步骤（3.2）。
答：Linux创建进程大体上有两个步骤：
1）fork() 函数通过拷贝当前进程创建一个子进程；
2）exec()函数负责读取可执行文件并将其载入到地址空间执行。
其中，Linux通过clone()系统调用实现fork()，由clone()去调用do_fork()，do_fork()调用copy_process()函数。
4、请画出进程状态转换图（3.1）。
答：
5、进程的终结（3.4）。P26
答：
6、linux2.6所实现的调度程序所实现的目标是什么（4.2）？
答：有效性：完成尽可能多的工作；交互性：尽快响应用户；公平性：不允许任何进程饥饿。
（1）充分实现O(1)调度。不管有多少进程，新调度程序采用的每个算法都能在恒定时间内完成；
（2）全面实现SMP的可扩展性。每个处理器拥有自己的锁和自己的可执行队列；
（3）强化SMP的亲和力。尽量将相关一组任务分配给一个CPU进行连续执行；
（4）加强交互性能。即使在系统处于相当负载的情况下，也能保证系统的相应,并立即调度交互式进程；
（5）保证公平。在合理设定的时间范围内，没有进程会处于饥饿状态，也没有进程能不公平的得到大量时间片；
（6）虽然常见的优化情况是系统中只有1-2个可运行进程，但是优化它也完全有能力扩展到具有多处理器每个处理器上运行多个进程的系统中。
7、请画出调度程序状态之间的关系（4.2）。
8、负载平衡程序的操作步骤（4.2.7）。
答：Linux为对称多处理器（SMP）系统中的每个处理器准备了单独的可执行队列和锁，而负载平衡程序则负责保证这些可执行队列之间的负载处于均衡状态。负载平衡程序由load_balance()函数实现，它所完成的操作步骤归结如下：
（1）找最繁忙的可执行运行队列；
（2）从最繁忙的队列中选择一个优先级数组（过期的优先）以便抽取进程；
（3）选择含有进程并且优先级最高（值最小）的链表；
（4）选择一个不是正在运行的且不在高速缓冲的进程，可移动的进程抽取；
（5）重复上述步骤，直至平衡。
9、用户抢占发生在什么情况（4.3.1）？
答：在内核即将返回用户空间的时候，如果need_resched标志被设置，会导致schedule()被调用，此时就会发生用户抢占。也就是说，用户抢占在以下两种情况发生：
1）从系统调用返回用户空间；    2）从中断处理程序返回用户空间。
10、内核抢占发生在什么情况（4.3.1）？
答：1）中断处理程序正在执行，且返回内核空间之前；
2）内核代码再一次具有可抢占性的时候（preemt_count重新为0）；
3）内核中的任务显示的调用schedule()；（处于核心态的任务直接调用schedule()）
4）内核中的任务阻塞时（这同样也会导致调用schedule()）。
11、请简述SCHED_FIFO与SCHED_RR实时调度的区别（4.4）。
答：SCHED_FIFO实现了一种简单的，先入先出的调度算法，它不使用时间片。SCHED_FIFO级的进程会比任何SCHED_NORMAL级的进程都先得到调度；SCHED_FIFO级进程不基于时间片，只要它处于可执行状态，就会一直执行，直到它自己受阻塞或显示的释放处理器为止。只有较高级的SCHED_FIFO或者SCHED_RR任务才能抢占SCHED_FIFO任务。
SCHED_RR与SCHED_FIFO大体相同，但是受时间片的限制。SCHED_RR级的进程在耗尽事先分配给它的时间片后就不能再接着执行了，也就是说，SCHED_RR是带有时间片的SCHED_FIFO，这是一种实时轮流调度算法。
12、系统调用作为进程与硬件之间的一个中间层所起的作用有哪些？（5）
答：系统调用在用户空间进程和硬件设备之间添加了一个中间层，该层主要有三个作用：
1）系统调用为用户空间提供了一种硬件的抽象接口；
2）系统调用保证了系统的稳定和安全；
3）系统调用是用户空间访问内核的唯一手段，除异常和陷入外，他们是内核唯一的合法入口。每个进程都运行在虚拟系统中，在用户空间和系统的其余部分提供这样一层公共接口，也是出于这种考虑。
13、中断为什么要分为上半部和下半部？解释tasklet思想。（6.2、7.3）
答：中断服务程序异步执行，可能会中断其他的重要代码，包括其他中断服务程序。因此，为了避免被中断的代码延迟太长的时间，中断服务程序需要尽快运行，而且执行的时间越短越好，所以中断程序只作必须的工作，其他工作推迟到以后处理。所以Linux把中断处理切为两个部分：上半部和下半部。上半部就是中断处理程序，它需要完成的工作越少越好，执行得越快越好，一旦接收到一个中断，它就立即开始执行。像对时间敏感、与硬件相关、要求保证不被其他中断打断的任务往往放在中断处理程序中执行；而剩下的与中断有相关性但是可以延后的任务，如对数据的操作处理，则推迟一点由下半部完成。下半部分延后执行且执行期间可以响应所有中断，这样可使系统处于中断屏蔽状态的时间尽可能的短，提高了系统的响应能力。实现了程序运行快同时完成的工作量多的目标。
中断的下半部可以通过多种机制实现，其中tasklet是常用的一种形式，而tasklet的实现基础是软中断。软中断作为下半部机制的代表随着SMP应运而生，它使得对时间不敏感的任务延后执行，而且可以在多个CPU上并行执行，它有以下特性：
（1）产生后并不马上可以执行，必须等待内核的调度才能执行。软中断不被自己打断，只能被硬件中断打断，或者唯一能抢占软中断的是上半部的中断处理程序；
（2）可以并发运行在多个CPU上（即使同一类型的也可以）。所以软中断必须设计可重入的函数（允许多个CPU操作），因此也需要使用自旋锁来保护。
那些执行频率很高、连续性要求很高并能高效完成加锁工作的应用才需要软中断，所以软中断的使用屈指可数——只有网络和SCSI直接使用软中断。而tasklet本身也是软中断，它和软中断在本质上很相似，行为表现也相近，tasklet内部对软中断进行了封装，外部接口更简单，锁保护也要求较低。它具有以下特性：
（1）一种特定类型的tasklet只能运行在一个CPU上，不能并行，只能串行；
（2）多个不同类型的tasklet可以并行在多个CPU上；
（3）软中断是静态分配的，在内核编译好后就不能改变，但tasklet就灵活许多，可在运行时改变。
Tasklet是在两种软中断类型的基础上实现的（HI_SOFTIRQ和TASKLET_SORFTIRQ），但是由于其特殊的实现机制，降低了设备驱动程序开发者的负担，因此如果不需软中断的并行性，tasklet就是最好的选择。
14、请简述下半部机制中软中断、tasklet、工作队列的优缺点以及使用场合？（6.2 7.3 7.4）
答：软中断：
——优点：可以并发运行在多个CPU上（及时同一类型的也可以），具有可扩展性；
——缺点：必须使用可重入函数，对锁要求高，实际复杂度高，静态分配不灵活；
——适用场合：对时间要求严格、执行频率很高和连续性要求很高的情况；
Tasklet：
——优点：接口更简单，锁保护要求低，而且两个不同类型的tasklet不能同时执行，所以实现简单，动态可变灵活性好，是有效的软终端；
——缺点：只能运行在一个CPU上，不能并发；
——使用场合：在不要求扩展到多CPU的话，尽可能选择tasklet而不是软中断。不能很好线程化的代码，tasklet意义更大；
工作队列：
——优点：
——缺点：造成的开销最大，因为要牵扯到内核线程甚至是上下文切换；
——使用场合：如果中断的延期工作需要运行于进程上下文，工作队列是唯一的选择。
15、造成并发执行的原因有哪些？
答：1）中断——中断集合可以在任何时刻异步发生，也就是可能随时打断当前正在执行的代码；
2）软中断和tasklet——内核能在任何时刻唤醒或调度软中断和tasklet，打断当前任务；
3）内核抢占——因为内核具有抢占性，所以内核中的任务可能会被另一任务抢占；
4）睡眠及用户空间的同步——在内核执行的进程可能会睡眠，这就会唤醒调度程序，从而导致调度一个新的用户进程执行；
5）对称多处理——两个或多个处理器可以同时执行代码。
16、请简述在分配内存中，如何选择内存分配函数。（11.6、11.13  P65）
答：（alloc_page、kmalloc、vmalloc、slab）
1）需要连续的物理页，就可以使用某个低级页分配器或kmalloc()，这是内核中默认分配常用方式；
2）想从高端内存进行分配，就使用alloc_pages()，alloc_pages()函数返回一个指向struct page结构的指针，struct page结构的指针是访问相应高端内存的唯一方式；而不是一个指向某个逻辑地址的指针，因为高端内存很多没有被映射；
3）不需要物理上连续的页，而仅仅需要虚拟地址上连续的页，那就使用vmalloc()函数，vmalloc()函数分配的内存虚拟地址是连续的，但它本身并不保证物理上的连续性，相对相对kmalloc()来说，有一定的性能损失；
4）创建和销毁很多较大的数据结构，那么应考虑建立slab高速缓存，slab层为每个CPU维持一个对象高速缓存（空闲链表），极大的提高对象分配和回收的性能。
17、请简述硬连接与软连接的区别（12）。
答：Unix下每个文件都有一个与之相关联的数据结构用来描述该文件的信息，这个数据结构就是inode。创建硬连接只是创建一个指针，一个指向inode的指针，所以硬连接不占磁盘空间。多个目录项对应一个inode号；连接计数变为0时，文件被删除。硬连接的创建有两个限制：1）不能为目录创建硬连接，避免循环；2）不能跨文件系统或者跨分区创建硬连接。
    软连接也叫符号连接，它本身是一个独立的较小的文件，指向新创建的inode，是文件的另一个路径的别名。软连接的创建没有限制，但是可能会造成循环。
18、请简述find_vma()与find_vma_prev()及find_vma_intersection()之间的区别。（14.3）
答：它们都是内核定义来管理内存区域的辅助函数，区别如下：
find_vma()函数在指定的地址空间中搜索第一个vm_end大于add的内存区域，即该函数寻找第一个包含addr或首地址大于addr的内存区域，如果没有发现这样的区域，该函数返回NULL，否则返回指向匹配的内存区域的vm_area_struct结构体指针；
find_vma_intersection()与find_vma()工作方式相同，但是它返回第一个vm_end小于addr的vm_end，find_vma_intersection()函数返回第一个和指定地址区间相交的VMA。
19、如何创建地址区间？（14.4）
答：在用户空间通过mmap()系统调用获取内核函数do_mmap()的功能，内核使用do_mmap()函数创建一个新的线性地址区间，如果创建的地址区间和一个已经存在的地址区间相邻，并且他们具有相同的访问权限的话，那么两个区间合并一个，如果不能合并，那么就确实需要创建一个新的VMA了，但无论哪种情况，do_mmap()函数都会将一个地址区间加入到进程的地址空间中——无论是扩展已存在的内存区域还是创建一个性的区域。
20、如何删除地址区间？（14.5）
答：系统调用munmap()函数给用户空间程序提供了一种从自身地址空间中删除指定地址区间的方法，它是对do_munmap()函数的一个简单的封装。Do_munmap()函数从特定的进程地址空间中删除指定地址空间。
21、信号量与自旋锁的区别？
答：当一个进程试图获取一个被占用的自旋锁时，它必须不断的查看锁是否被释放，而对信号量来说，进程不必一直忙等，而是把自己登记到一个等待队列中，然后自己睡觉去了。
信号量：适用于锁会被长时间持有的情况；
自旋锁：适用于被短时间占有的锁。
22、同步的方法。
答：原子操作：是指不会被线程调度机制打断的操作，这种操作一点开始，就一直运行到结束，中间不会切换到另一个线程；
自旋锁：为了实现保护共享资源，防止多处理器并发而提出的一种锁机制。一个执行单位要想访问被自旋锁保护的共享资源必须先得到锁，否则将自旋等待获取锁；
信号量：是一种睡眠锁，没有获得信号量的任务则进入等待队列睡眠，直到信号量被释放后才被唤醒，获得信号量去执行；是在多线程环境下用来保证两个或多个关键代码段不被并发调用的一种设施。在进入一个关键代码段钱线程必须获取一个信号量，执行完成后释放信号量；
完成变量：若在内核中一个任务需要发出信号通知另一个任务发生了某个特定事件，则使用完成变量，完成变量唤醒在完成变量上等待的任务；
BKL（大内核锁）：大内核锁基于小等待自旋锁，是一个全局自旋锁，可以使一个进程多次请求锁（递归锁），保证一个进程只能取得一次锁，在释放前任何锁定动作都不会导致实质上再次锁定，这样避免本进程多次锁定而导致死锁。
23、对进程控制块的处理，Linux和Unix有什么区别？为什么有这种区别？有什么好处？
答：1）Unix的进程控制块由基本控制块proc结构和扩充控制块user结构两部分组成。
——Proc结构中存放关于一个进程的最基本、最必须的信息，因此它常驻内存；
——User结构中存放着只有进程运行时才用到的数据和状态信息，因此为了节省主存空间，当进程暂时不在处理机上运行时，就把它放在磁盘上的对换区中。进程的user结构总和进程数据段一起换入换出主存；
2）Linux中slab分配器动态分配task_struct，对象复用和缓存。
3）造成这种却别是由于内存的限制，早期Unix时代机器内存小，分部处理节省内存空间；而随着技术进步内存有了显著提升，Linux的处理方式更加高效、快速。

24、进程与线程有什么区别？Linux线程是如何实现的？
答：进程是出于执行期的代码以及它包含的资源的总称，而线程是进程中活动的对象。进程是资源管理的最小单位，线程是程序执行的最小单位，内核调度的对象是线程而不是进程。采用线程是为了更好的支持SMP以及减小上下文切换的开销，因为线程上下文切换开销比进程小多了。一个进程至少需要一个线程作为它的指令执行体，进程管理着资源，将线程分配到某个CPU上执行，SMP中可使用多个CPU执行各个线程，达到最大程度的并行。
    Linux线程的实现：Linux实现线程的机制非常独特，内核把所有的线程都当做进程来实现，线程只被视为一个与其它进程共享某些资源的进程。每个线程拥有独立的程序计数器、进程栈和一组进程寄存器，并且和进程一样拥有唯一隶属于自己的task_struct。
25、有几种锁？按理只要设计一种锁对要访问的关键数据加锁就可以了，为什么要设计几种锁？这几种锁有什么区别？
答：有五种锁：原子操作；自旋锁；信号量；BKL；seq锁；
使用锁的上下文环境不同，加锁的时间长短不同，维护锁的开销不同，所以要设计几种锁来适应不同使用情况。
    原子操作保证指令执行过程不被打断；自旋锁快速简单，加锁时间不长且代码不会休眠；而信号量则适用于加锁时间长且允许睡眠的情况；而BKL锁允许递归使用，不会出现死锁，但很少被使用且是有害的；seq锁适用读写共享数据，轻量级，对写者有利，读者循环等待。
26、举例说明Linux操作系统中，哪些地方实现了面向对象的思想？
答：面向对象的思想有三个基本特征：封装、继承、多态。
封装就是把方法和属性包装起来，实现信息隐蔽和抽象；继承是指一个对象直接使用另一个对象的属性和方法；而多态是指接口的多种不同的实现方式。
Linux内核中多种技术都体现了面向对象的设计思想，下面分别从面向对象的三个特征分别阐述：
1）文件系统的file对象，file对象只定义了方法的原型而没有事项。具体方法的实现由具体的文件系统提供。内核中重要数据结构都进行封装，如文件系统中的inode对象，内存管理中的page对象、cache对象和slab对象，网络实现部分中的sochet缓冲对象、struct sk_buff等；
2）内核中的通用链表结构可看作一个基类。对它的基本操作是链表节点插入、删除、初始化和移动，而其他数据结构可视为它的子类。若它们要组织成双向链表，可以在链表节点中包含这个通用链表对象，而使用通用链表的数据结构遍及内核的各个部分：进程调度、存储器管理、文件系统、网络协议栈等。
3）虚拟文件系统（VFS）典型的体现了多态性。VFS可看作抽象基类，而具体的文件系统如ext2、VFAT可看作它的子类，VFS提供的操作函数集是一个纯虚函数概念，具体实现由实现文件系统提供。
27、中断上下文和进程上下文的区别？中断是否一定要在中断上下文中？
答：用户空间的应用程序通过系统调用进入内核空间，此时进程要传递很多变量，参数的值给内核，内核态运行时也要保存用户进程的一些寄存器值、变量号。所谓“进程上下文”，可以看作是用户进程传递给内核的这些参数以及内核要保存的那些变量和寄存器的值和当时的环境。
硬件通过触发信号，导致内核调用中断处理程序，进入内核空间，这个过程硬件的一些变量也要传递给内核，内核根据这些参数进行中断处理。所谓“中断上下文”可以看作是硬件传递的参数和内核需要保存的一些其他环境。
当某进程在执行时被内核切换去执行另一个进程，则它要保存当前的进程上下文一保证再次执行进程时能够获得切换时的状态并执行下去。
发生中断时，内核就在被中断进程上下文中，在内核态下执行中断服务例程，但同时保留所需要的资源，以便中断服务结束后能恢复被中断进程的执行。
当执行一个中断处理程序或下半部时，内核处于中断上下文。进程上下文可以睡眠，而中断上下文不可睡眠，两者之间没有瓜葛。
28、task_struct的作用，10个以上成员及其作用？
答：在Linux中每个进程都由task_struct数据结构来定义。进程的所有操作都要依赖task_struct，task_struct是进程存在的唯一标志，创建进程时，系统会为我们产生一个task_struct结构，然后从父进程那里继承一些数据，并把新进程插入到进程树中，以待进行进程管理。
下面列举一些task_struct结构中的成员以及它们的作用：
1）stae——标识进程的当前状态；
2）flags——进程标识；
3）addr_limit——线程地址空间；
4）has_cpu——获取的处理器；
5）priority——进程优先级；
6）lock_depth——锁深度；
7）pid_tpid——进程标识号；
8）pid_tpgrp——进程组号；
9）structmm_struct *mm——内存管理信息；
10）structfs_struct *fs——系统跟踪进程所打开的文件；
11）structfiles_struct *files——用户打开的文件表；


研究生考试 - 真题
2009真题
一、名词解析（25分）
1、写时拷贝
2、内核抢占
3、延时写
4、系统调用
5、内核模块
二、在进程控制处理模块方面，linux和unix的实现区别是什么？为什么会产生这种区别？（10分）
三、为什么要分上下部？简述tasklet的思想? （10分）
四、进程和线程的区别是什么？Linux是如何实现线程的？（10分）
五、进程的状态有哪些？画出状态转换图（15分）
六、内核的锁的实现方式有哪些？内核只要一个锁就能锁定数据结构，为什么还实现多种方式的锁？（15分）
七、举例说明内核的某一块设计是利用面向对象技术的（15分）

2010真题
名词解释
内核抢占 内核线程 current宏 proc文件系统
内核开发特点
什么是中断上下文，什么进程上下文，他们之间的区别
进程有哪几种状态，画出转换图
Linux如何实现线程
Linux如何实现task O（1）调度
系统调用和c库函数的作用
为什么分上下半步，下半部的处理方式有哪些
内核同步方法，为什么要分这几种方法


辨析题
社会主义包括社会主义思想和制度
列宁之所以提出一国胜利论关键在于他认为苏联可以绕过那个什么峡谷
当今世界资本主义的主要新现象是跨国集团垄断
唯物史观是社会主义由空想变为科学的思想路线
改革的必然性是苏联旧体制的局限性
材料题（记不住材料，只有题目）
简述邓小平对社会主义本质和新任务的概括
列宁提出的各国社会主义方式不同，对我国建设有中国特色的社会主义的启示
新经济政策的原因，内容，本质
当代资本主义的经济管理究竟出现了什么
三．论述题
论述我国作为社会主义国建如何应对经济全球化？


2011真题
1.名词解释
内核可抢占
内核线程
current宏
proc文件系统
2.内核开发的特点
3.linux线程的实现
4.什么是中断上下文,进程上下文,两者的区别是什么?
5.进程有多少种状态,如何转换?
6.如何实现task的O(1)调度
7.系统调用和C库函数有什么联系?
8.为什么中断要分上下半部?linux2.6下半部的实现有哪些?
9.linux2.6有多少种同步方法?为什么不同场合要用不同的同步方法?
